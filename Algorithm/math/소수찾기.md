# 소수찾기

> 프로그래머스에서 기초 문제 풀때 답 안보고 혼자 해보려다 계속 실패하던 소수 알고리즘이다.
>
> 에라토스테네스의 체를 사용하면 여러 수의 소수여부를 판단할 때 좋다는 것을 알았다.
>
> 이 마크다운은 백준의1978 소수찾기 문제를 풀며 작성했다.



## 개념



일단 소수가 뭔지 알아보자

**소수**(Prime number)란 **약수가 1과 자기자신뿐인 수**이다.

여기서 1은 1과 자기자신이 같아버리기 때문에 포함되지 않고,

2, 3, 5, 7, 11, 13, 17...

이렇게가 소수이다.



## 풀이



나는 처음 생각할 때 (2 ~ 나보다 작은수)들로 나를 나눠봐서 나눠떨어지면 소수가 아니다! 라고 생각해 알고리즘을 썼다.



```java
int n = 17
boolean result = true;

for(int i = 2; i < 17; i++){
    
    if(n % i == 0){
        result = false;
        break;
    }
}

return result;
```



이 방법이 나쁜게아니다. 오히려 한가지 수(n)이 소수인지 아닌지만 알고싶을 때는 유용하다.



**하지만** 



자연수 1000 이하의 수 16개 중에서 소수가 몇개있는지 구하려면..?

위 알고리즘이 16번 돌아야한다. 

이를 더 빠르게 하기 위한 알고리즘이 **에라토스테네스의 체** 이다.



## 에라토스테네스의 체



![img](https://t1.daumcdn.net/cfile/tistory/2324F43E5246ED5A2D)



위의 그림을 보면 쉽게 이해할 수 있다.

가령 2는 소수지만 2의 배수들 즉 4, 6, 8, 10, 12 ... 등은 몽땅 소수가 아니게 된다.

이를 이용해서 반복문이 돌때(i = 2 ~ n) 반복문 안에서 i의 배수인 수들을 모두 먼저 들려서 소수가 아님을 표시하는 것이다.



코드를 보면



```java
	// 1000 이하의 숫자들의 소수여부를 담을 배열을 선언한다.
    int [] arr = new int [1001];

	// 2부터 1000까지 배열에 자기 위치의 숫자로 초기화한다.
	// 1은 소수가 아니니 그냥 0으로 둔다.
    for(int i=2; i<=1000; i++) {
        arr[i] = i;
    }

    for(int i=2; i <= Math.sqrt(1000); i++ ) {
        
        if( arr[i] == 0) {
            continue;
        }
        for(int j = i+i; j<=1000; j+=i) {
            arr[j] = 0;
        }
    }

```



배수들을 몽땅 소수후보에서 제외할 i를 이용해  for 문을 돈다.

j는 i+i 로 시작하는데 이유는 i는 소수일 수 있기 때문이다.

가령 i가 2라면 2는 소수니까 j는 4부터 반복하며 arr[ j ]을 0으로 만들어야 한다.

j는 i의 배수인 격이니 for문반복때마다 i를 더해준다.



저 중간에 있는

```java
if( arr[i] == 0) {
            continue;
        }
```

도 효율을 위해 중요하다. 가령 i가 2 와 3 을 거쳐 4 가 되었다고 생각해보자.

이미 i가 2일때 2의 배수들의 배열은 모두 j반복문에서 0이 되었다.

이는 2의 배수인 4는 더이상 j반복문을 거칠 필요가 없는 것이다. (이미 i = 2일때 4의 배수들도 모두 0이 되었으므로)

따라서 arr[i] == 0인 경우 뒤의 j반복문을 거치지 않고 바로 i를 증가시켜 다음 검사를 수행하면

시간을 단축시킬 수 있다.



마지막으로 i가 루트 1000만큼만 검사해도 소수 여부를 파악할 수 있다고 하니 그것도 체크!







